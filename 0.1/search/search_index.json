{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Work in Progress</p> <p>The documentation for this project is still in progress. Many submodules still have missing explanation and examples, They will be updated as soon as possible.</p> <p>Proof Read Needed</p> <p>Writing proper English is not easy. Sentences need to be restructured and grammars need to be fixed for the documentation to be a good read. If you're interested in helping a poor fellow out, please contact me by opening an issue.</p> <p>Maleo is an opiniated Golang library / framework to handle Errors, Logging, and Notification. All of those are handled in one swoop to enhance developer experience.</p> <p>Maleo's purpose is to give certain understanding on how an Error happened, but not just for the developer him/herself, but also the team, QA, or anyone else in the team who have the same privilege and collective interest (e.g. your tech lead or product manager who wants to understand where the fault lies).</p> <p>So basically, when something goes down, the whole gang knows there's a problem and the cause of the reason is available to them, not just the devs.</p> <p>If you want to know the motivation why this exist check here.</p>"},{"location":"#features","title":"Features","text":"<ol> <li> <p>Designed for error chaining. Auto inference support when wrapping errors to reduce tediousness. See    Auto Inference for details on how it works.</p> Returning Rich Error Example<pre><code>if err != nil {\n// Tries to detect your error when maleo.Wrap is called.\n// Filling `code` and `message` automatically when found.\n//\n// Or override them by configuring the builder that is returned by Wrap.\nreturn maleo.Wrap(err).\n// Code(400).\n// Context(maleo.F{\"user\": user}).\n// Message(\"failed to find user id from database\").\nFreeze()\n}\n</code></pre> </li> <li> <p>Easy logger and notification call in one flow.</p> Easy Logger and Notification<pre><code>if err != nil {\nreturn maleo.Wrap(err).\nCode(400).\nContext(maleo.F{\"foo\": \"bar\"}).\nMessage(\"message test\").\nLog(ctx). // Log your error.\nNotify(ctx) // Notify your error to Discord or something else.\n}\n</code></pre> </li> <li> <p>Collect only relevant Stack traces informations. While <code>runtime.Stack</code> method is available, it prints too many    informations. Most of the time I just want to know \"who calls this?\", and want just that information and don't care    about other libraries.</p> </li> <li> <p>Easily extensible. You can easily add your own Logger and Messengers to use your favorite logger library and    notification services respectively.</p> </li> <li> <p>Support integration with popular libraries and platforms. Like zap,    Amazon S3, Minio, Discord.</p> </li> </ol>"},{"location":"quick-start/","title":"Quick Start","text":"<p>Maleo by default does nothing. It will still do the wrapping and some nice stuffs around as one might expect, but every call to <code>Log</code> and <code>Notify</code> from all sources will be a Noop if you don't configure it.</p> <p>It is by design so it can interop easily with unit tests. So there's no need to call <code>maleo.SetGlobal</code> on unit tests.</p> Setup<pre><code>func setupMaleo() {\n// Service provides metadata to know where does this log\n// or notification comes from.\n//\n// It does not have any other impact as far as\n// Maleo and Maleo's built-in integration concerns.\n//\n// But You can use this information for your custom implementations later.\n//\n// No field is required, but it's recommended\n// to set at the very least the name and environment.\n// So when you receive a notification,\n// you can easily distinguish if it comes from prod or dev for example.\nservice := maleo.Service{\nName: \"secret service\",\nEnvironment: \"development\",\nType: \"kafka-consumer\",\n}\nmal := maleo.NewMaleo(service, maleo.Option.Init().\nLogger(). // Set a logger to use.\nMessengers(), // Set your messengers.\n)\nmaleo.SetGlobal(mal) // Set the global Maleo instance. Optional.\n}\n</code></pre> <p>Setup is best done in the earliest possible in your code. <code>maleo.SetGlobal</code> does not support <code>Mutex</code> and may cause unexpected result when called in concurrent manner.</p> <p>After you setup Maleo, you can use it anywhere in your code.</p> Use<pre><code>func foo() {\ndata, err := doSomethingCool()\nif err != nil {\n// Uses global instance when using direct functions.\nreturn nil, maleo.Wrap(err).Message(\"something went wrong\").Log(ctx)\n}\n}\n</code></pre>"},{"location":"quick-start/#testing","title":"Testing","text":"<p>If you wish to test the log output, Maleo supports a very basic JSON logging outputs. It's not meant for production use.</p> Test<pre><code>func TestSomeFunc(t *testing.T) {\nmal, log := maleo.NewTestingMaleo()\n_ = mal.Wrap(errors.New(\"foo\")).Log(context.Background())\nout := log.String() // or log.Bytes()\nif !strings.Contains(out, \"foo\") {\nt.Fatal(\"expected to contain foo\")\n}\n}\n</code></pre> <p>This method is useful when you want test implementation against Maleo. Very nice when combined with jsonassert testing library.</p> <p>Obviously, this method is not very effective if your codebase uses global instance. You have to meddle with global instance which most likely need some further setups of your test, and thus a not recommended approach.</p> <p>It's best to just test the error directly instead of the log output in this case.</p>"},{"location":"customizing/","title":"Maleo","text":"<p>Maleo by default, does nothing.</p>"},{"location":"documentation/bucket/","title":"Bucket","text":"<p>Bucket provides a way for Messengers to store files.</p> <p>You can add your own Bucket by implementing the following signature:</p> <pre><code>type Bucket interface {\n// Upload File(s) to the bucket.\n//\n// Implementor must check if File.Data() implements io.Closer and call Close() on it after the upload is complete.\n//\n// Whether the upload is successful or not, the implementor must call File.Close() on all files received.\n//\n// UploadResult.File must be filled with File of the same index and UploadResult.Error must be filled with error if\n// upload operation fails.\n//\n// The number of UploadResult must be the same as the number of files in the parameter.\nUpload(ctx context.Context, files []File) []UploadResult\n}\n</code></pre> <p>The <code>Bucket.Upload</code> method is the entry point for you to execute your own upload logic.</p> <p>Rate limit and retry are handled by the implementor (a.k.a. you).</p> <p>Maleo's built-in Messengers will wait for the <code>Upload</code> method to return before sending the message. The same cannot be said for custom Messengers. Consult the documentation of your custom Messenger for more information.</p>"},{"location":"documentation/bucket/#file","title":"File","text":"<p><code>File</code> is a representation of data that is about to be uploaded into a Bucket.</p> <p><code>File</code> has the following signature:</p> <pre><code>type File interface {\nData() io.Reader\nFilename() string\nContentType() string\nRead(p []byte) (n int, err error)\nPretext() string\nSize() int\nClose() error\n}\n</code></pre> <p>You can easily construct your own <code>File</code> by calling:</p> <pre><code>bucket.NewFile(data io.Reader, mimetype string, opts ...FileOption) File\n</code></pre>"},{"location":"documentation/bucket/minio/","title":"Minio","text":"<p>Maleo Minio is an implementation of Bucket wrapping around Minio SDK Go v7.</p>"},{"location":"documentation/bucket/minio/#installation","title":"Installation","text":"<pre><code>go get github.com/tigorlazuardi/maleo/bucket/maleominio/v2\n</code></pre>"},{"location":"documentation/bucket/minio/#usage","title":"Usage","text":"<p>Usage is pretty straight forward. Create a client, and call <code>maleominio.Wrap()</code> around the client.</p> <p>Requirements</p> <p>Ensure your credential is allowed to execute <code>PutObject</code> Api on target bucket.</p> <p>Auto Bucket Create</p> <p>If your credential support creating bucket, it will create the bucket if does not exist.</p> <p>Using on AWS</p> <p>Minio client supports AWS S3 protocols. So you can also use this bucket implementation for AWS.</p> MinioAWS <pre><code>\n</code></pre> <pre><code>\n</code></pre>"},{"location":"documentation/bucket/s3/","title":"S3 (V2)","text":"<p>S3 is an implementation of Bucket integration for Amazon Simple Storage.</p> <p>Currently supported S3 client is from aws-sdk-go-v2.</p>"},{"location":"documentation/bucket/s3/#installation","title":"Installation","text":"<p>Run the following command to install the package:</p> <pre><code>go get github.com/tigorlazuardi/maleo/bucket/maleos3-v2\n</code></pre>"},{"location":"documentation/bucket/s3/#usage","title":"Usage","text":"<p>There are 3 ways to initialize the S3 Bucket implementation.</p> <p>Requirement</p> <p>Your credential chain must have permission to call <code>PutObject</code> API on the bucket. Otherwise it will fail to upload.</p> <p>Auto Create Bucket</p> <p>If your credential chain have permission to create bucket, and your bucket does not exist in AWS, maleos3 will create one for you.</p>"},{"location":"documentation/bucket/s3/#1-default-credential-chain","title":"1. Default credential Chain","text":"<p>This is arguably the easiest to setup. This support EC2 instance role, read credentials from <code>~/.aws/credentials</code> file, or from environment variables for authentication.</p>"},{"location":"documentation/bucket/s3/#2-simple-static-credential","title":"2. Simple Static Credential","text":"<p>If your services do not run in EC2 instance or for some reason you don't want to set environment variables (e.g. rolling out your own secret management service), using simple static credentials are perhaps the best method for you.</p>"},{"location":"documentation/bucket/s3/#3-using-custom-client","title":"3. Using Custom Client","text":"<p>If you have complex client setup, just simply pass your own client configuration.</p>"},{"location":"documentation/bucket/s3/#setup","title":"Setup","text":"Default Credential ChainSimple Static CredentialUsing Custom Client <pre><code>func ExampleNewS3Bucket() {\nbkt, err := maleos3.NewS3Bucket(\"my-bucket.s3.us-east-1.amazonaws.com\")\nif err != nil {\nreturn\n}\nf := strings.NewReader(\"hello world\")\nfile := bucket.NewFile(f, \"text/plain; charset=utf-8\")\nfor _, result := range bkt.Upload(context.Background(), []bucket.File{file}) {\nif result.Error != nil {\n// handle error\nreturn\n}\n}\n}\n</code></pre> Static Client<pre><code>func ExampleNewS3Bucket_static() {\nclient, err := maleos3.SimpleStaticClient(maleos3.SimpleStaticParams{\nAccessKeyID:     \"access_key\",\nSecretAccessKey: \"secret_key\",\nSessionToken:    \"\", // Optional. Leave empty if not needed.\n// Endpoint is needed to be set for non-AWS S3, otherwise just leave empty.\n// It is needed as interoperability with other S3 compatible services.\nEndpoint: \"\",\n// Same reason as above\nRegion: \"\",\nSecure: true, // Set false if you want to use HTTP instead of HTTPS.\n})\nif err != nil {\nreturn\n}\nbkt, err := maleos3.NewS3Bucket(\"my-bucket.s3.us-east-1.amazonaws.com\", maleos3.WithClient(client))\nif err != nil {\nreturn\n}\nf := strings.NewReader(\"hello world\")\nfile := bucket.NewFile(f, \"text/plain; charset=utf-8\")\nfor _, result := range bkt.Upload(context.Background(), []bucket.File{file}) {\nif result.Error != nil {\n// handle error\nreturn\n}\n}\n}\n</code></pre> <pre><code>func ExampleNewS3Bucket_custom() {\nclient := s3.NewFromConfig(aws.Config{\n// set your custom config here\n})\nbkt, err := maleos3.NewS3Bucket(\"bucket.s3.us-east-1.amazonaws.com\", maleos3.WithClient(client))\nif err != nil {\nreturn\n}\nf := strings.NewReader(\"hello world\")\nfile := bucket.NewFile(f, \"text/plain; charset=utf-8\")\nfor _, result := range bkt.Upload(context.Background(), []bucket.File{file}) {\nif result.Error != nil {\n// handle error\nreturn\n}\n}\n}\n</code></pre>"},{"location":"documentation/bucket/s3/#non-aws-s3-services","title":"Non AWS S3 Services","text":"<p>For services who are support S3 protocol, they may be able to interop with AWS SDK v2.</p> <p>Limited Support</p> <p>Support for Non AWS S3 is very limited. It may or may not work with your S3 like server. You may have to roll your own client and configuration.</p> Non AWS Service<pre><code>func ExampleNewS3Bucket_nonAws() {\nclient, err := maleos3.SimpleStaticClient(maleos3.SimpleStaticParams{\nAccessKeyID:     \"access_key\",\nSecretAccessKey: \"secret_key\",\nEndpoint:        \"minio:9000\",\nRegion:          \"us-east-1\",\n})\nif err != nil {\nreturn\n}\nbkt, err := maleos3.NewS3Bucket(\"minio:9000\", maleos3.WithClient(client))\nif err != nil {\nreturn\n}\nf := strings.NewReader(\"hello world\")\nfile := bucket.NewFile(f, \"text/plain; charset=utf-8\")\nfor _, result := range bkt.Upload(context.Background(), []bucket.File{file}) {\nif result.Error != nil {\n// handle error\nreturn\n}\n}\n}\n</code></pre>"},{"location":"documentation/locker/","title":"Locker","text":"<p>Locker is an interface for Maleo's built-in messenger to synchronize state between services.</p> <p>It is used to enable rate limit on the API (so your Messengers don't get banned) even when your services are distributed.</p> <p>To create your own <code>Locker</code> implementation, you have to implement the following interface:</p> <pre><code>type Locker interface {\n// Set the key and value.\nSet(ctx context.Context, key string, value []byte, ttl time.Duration) error\n// Get the Value by Key.\nGet(ctx context.Context, key string) ([]byte, error)\n// Delete value by key.\nDelete(ctx context.Context, key string)\n// Exist Checks if key exist in cache.\nExist(ctx context.Context, key string) bool\n// Separator Returns Accepted separator value for the Lock implementor.\nSeparator() string\n}\n</code></pre>"},{"location":"documentation/locker/#local-lock","title":"Local Lock","text":"<p>Local lock is an in memory lock. It's a special lock that only applies to current runtime.</p> <p>There are no synchronization between services, and thus states like backoff are not synchronized between services.</p> <p>The lock is useful when you want to create simple prototype services, but in deployed environment, please use more sophisticated services to handle synchronization and persistence.</p> <p>You can create a simple local lock by calling:</p> <pre><code>lock := locker.NewLocalLock()\n</code></pre>"},{"location":"features/auto-inference/","title":"Auto Inference","text":""},{"location":"trivia/why-does-this-library-exist/","title":"Why does this library exist?","text":"<p>Errors are a part of life in a development life cycle. Naturally, everyone have their own way to handle errors. But, what I found lacking in Go is support for rich error informations.</p> <p>Generally, to easily debug an information, you will need to log the error (the output), and the input a.k.a. what data is entered to produce such error.</p> common error handling pattern<pre><code>if err != nil {\nreturn fmt.Errorf(\"failed to find user '%s' from database: %w\", userId, err)\n}\n</code></pre> <p>Something like above is usually enough... when your function is rather simple in logic and the caller's logic is rather straight forward. It became another story when you have a dozen error handling like this in the codebase.</p> <p>Of course, anyone can make themselves an <code>error</code> instance that can carry such information or use a library.</p> <p>But I always found something lacking. Rich Error is one thing, but sometimes I want that error thrown into my face. Of course, to do that, I either have to pull another library or make my own. Not to mention, I also do not want to be spammed by my own program when that Error appears (e.g. database down). I only need to know one error! Not many.</p> <p>Also, there's an issue of collecive knowledge on a team.</p> <p>It's nice if you work in one man project or old team on existing project. You can do something specialized with your project when handling errors and everyone else in the team know the best practics to handle errors.</p> <p>It suddenly became a pain when you have to onboard someone new to the project since you have to mentor how to handle errors, how to write that rich error themselves, severity, how to send notification of a project, etc.</p> <p>Wouldn't it be nice if there's a library to handle all of those tasks? Enter <code>Maleo</code> to handle majority of the haul of said problem.</p>"}]}